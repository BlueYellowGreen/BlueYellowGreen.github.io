(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{388:function(e,t,_){},445:function(e,t,_){"use strict";_(388)},512:function(e,t,_){"use strict";_.r(t);_(445);var v=_(33),s=Object(v.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h3",{attrs:{id:"_2022-02-22-새로-알게된-점"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2022-02-22-새로-알게된-점"}},[e._v("#")]),e._v(" 2022/02/22, 새로 알게된 점")]),e._v(" "),_("p",{staticClass:"tags"},[e._v("#baseline")]),e._v(" "),_("br"),e._v(" "),_("h3",{attrs:{id:"대회-d-9"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#대회-d-9"}},[e._v("#")]),e._v(" 대회 D-9")]),e._v(" "),_("p",[e._v("  AIStages 웹 페이지 속 경진대회에 참가하여 GPU 서버를 사용할 수 있었다."),_("br"),e._v("\n서버를 생성하면 SSH 접속을 위한 key 파일도 함께 제공되어서, VSCode 를 통해 접속하였다.\n접속 방법은 이전에 설명했던 Colab 을 VScode 로 접속하는 것과 거의 유사하다.")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("다운받은 key 파일을 "),_("code",[e._v("/Users/계정_이름/.ssh/")]),e._v(" 경로에 붙여넣는다.")])]),e._v(" "),_("li",[_("p",[e._v("Remote-SSH (VSCode Extention) 이 없다면 설치한 뒤, "),_("code",[e._v("Ctrl + Shift + P")]),e._v(" 를 누르고 "),_("code",[e._v("Remote-SSH: Add New SSH Host")]),e._v(" 를 입력한다.")])]),e._v(" "),_("li",[_("p",[e._v("주소를 입력하면 끝! (ex. "),_("code",[e._v("ssh -i root@주소 -p 포트번호")]),e._v(" )")])])]),e._v(" "),_("p",[e._v("위 과정 진행 중에 configuration 과정에서 에러가 발생한다면, "),_("code",[e._v("/Users/계정_이름/.ssh/")]),e._v(" 경로의 "),_("code",[e._v("config")]),e._v(" 파일 속,\n접속하고자 하는 주소의 "),_("code",[e._v("IdentityFile")]),e._v(" 값을 "),_("code",[e._v("~/.ssh/key")]),e._v(" 로 수정하면 된다.")]),e._v(" "),_("br"),e._v(" "),_("p",[e._v("현재 구축한 baseline 은 다음과 같다.")]),e._v(" "),_("img",{attrs:{src:"https://raw.githubusercontent.com/BlueYellowGreen/BlueYellowGreen.github.io/main/.vuepress/public/assets/img/baseline.png"}}),e._v(" "),_("p",[e._v("더 좋은 방식이 있겠지만, 일단 구현해볼 수 있는 기초 코드 구조이다.")]),e._v(" "),_("br"),e._v(" "),_("ul",[_("li",[_("p",[_("strong",[e._v("model.py")])]),e._v(" "),_("ul",[_("li",[e._v("생각나는 아이디어를 class 로 자유롭게 구현하고, 추후 "),_("code",[e._v("train.py")]),e._v(" 에서 해당 모델 클래스를 가져온다.")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("augmentation.py")])]),e._v(" "),_("ul",[_("li",[e._v("Data Augmentation 작업을 하다보면 transforms.Compose 부분이 길어져서, 따로 빼놓았다. dataset.py 에서 해당 transforms 를 불러와서, forward 에서 사용한다.")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("dataset.py")])]),e._v(" "),_("ul",[_("li",[e._v("이미지를 어떻게 읽어오는지 구현한 부분으로, 서버의 폴더 구조가 바뀌지 않는 이상 자주 변경되지 않을 것 같다.")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("dataloader.py")])]),e._v(" "),_("ul",[_("li",[_("code",[e._v("dataset.py")]),e._v(" 의 데이터셋을 불러와 데이터로더로 구현한 것으로, 주로 train 과 valid 를 나누는 작업이 진행된다.\n현재는 단순히 "),_("code",[e._v("torch.randperm")]),e._v(" 을 통해 섞고 "),_("code",[e._v("torch.index_select()")]),e._v(" 를 통해 불러오지만, 클래스 불균형을 해소하기 위해 다른 방식으로 구현해보려고 한다.")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("train.py")])]),e._v(" "),_("ul",[_("li",[e._v("train / valid 가 이루어지는 부분으로, CLI 환경에서 진행하기 위해 argument parser 를 정의하였다. 코드를 더욱 깔끔하게 하기 위해 train.py 를 trainer.py 로 바꾸고,\ntrain 과 valid 를 각각의 컴포넌트로 분리할 수도 있겠지만, 일단 하지 않았다. 그리고, wandb 에 연결하여 "),_("code",[e._v("loss")]),e._v(", "),_("code",[e._v("precision")]),e._v(", "),_("code",[e._v("recall")]),e._v(", "),_("code",[e._v("f1_score")]),e._v(" 를 기본적으로 기록한다.")])])])]),e._v(" "),_("br"),e._v(" "),_("p",[e._v("더 나아가, early stopping 등 기능들을 추가할 예정이다.")]),e._v(" "),_("br"),e._v(" "),_("br")])}),[],!1,null,"24137089",null);t.default=s.exports}}]);