<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>02/14 Summary | LDH Note</title>
    <meta name="generator" content="VuePress 1.8.3">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16.png">
    <link rel="shortcut icon" href="/assets/favicons/favicon.ico">
    <script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-23KGQVB87M"></script>
    <script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-23KGQVB87M');</script>
    <meta name="description" content="부스트캠프 AI Tech 02/14 Summary">
    <meta property="og:title" content="02/14 Summary">
    <meta property="og:description" content="부스트캠프 AI Tech 02/14 Summary">
    <meta property="og:image" content="https://boostcamp.connect.or.kr/images/pavicon_180_v2.ico">
    <meta property="og:url" content="https://leedooho.com/AI/Boostcamp-AI-Tech/0214.html">
    <meta name="charset" content="utf-8">
    
    <link rel="preload" href="/assets/css/0.styles.10edf211.css" as="style"><link rel="preload" href="/assets/js/app.0ef05f26.js" as="script"><link rel="preload" href="/assets/js/2.7be8156e.js" as="script"><link rel="preload" href="/assets/js/29.b8b165d9.js" as="script"><link rel="preload" href="/assets/js/37.c7880ac5.js" as="script"><link rel="prefetch" href="/assets/js/10.52419b77.js"><link rel="prefetch" href="/assets/js/11.662ba05b.js"><link rel="prefetch" href="/assets/js/12.189d6f01.js"><link rel="prefetch" href="/assets/js/13.81ecece4.js"><link rel="prefetch" href="/assets/js/14.a674bf1c.js"><link rel="prefetch" href="/assets/js/15.3da3c840.js"><link rel="prefetch" href="/assets/js/16.e18de7c7.js"><link rel="prefetch" href="/assets/js/17.5d3e9bea.js"><link rel="prefetch" href="/assets/js/18.ad7065eb.js"><link rel="prefetch" href="/assets/js/19.c89a62e1.js"><link rel="prefetch" href="/assets/js/20.733b42dd.js"><link rel="prefetch" href="/assets/js/21.d6485c5d.js"><link rel="prefetch" href="/assets/js/22.5294f975.js"><link rel="prefetch" href="/assets/js/23.4184da9c.js"><link rel="prefetch" href="/assets/js/24.e5607ab0.js"><link rel="prefetch" href="/assets/js/25.b62df304.js"><link rel="prefetch" href="/assets/js/26.295961da.js"><link rel="prefetch" href="/assets/js/27.a79d73e1.js"><link rel="prefetch" href="/assets/js/28.bf78ea18.js"><link rel="prefetch" href="/assets/js/3.76558b67.js"><link rel="prefetch" href="/assets/js/30.9c2ce01a.js"><link rel="prefetch" href="/assets/js/31.1b46576c.js"><link rel="prefetch" href="/assets/js/32.1821c629.js"><link rel="prefetch" href="/assets/js/33.bf1751a1.js"><link rel="prefetch" href="/assets/js/34.45b4dd8e.js"><link rel="prefetch" href="/assets/js/35.62876489.js"><link rel="prefetch" href="/assets/js/36.b909f7e6.js"><link rel="prefetch" href="/assets/js/38.a6bd5a4b.js"><link rel="prefetch" href="/assets/js/39.01c90e8d.js"><link rel="prefetch" href="/assets/js/4.a9922f00.js"><link rel="prefetch" href="/assets/js/40.47859ce2.js"><link rel="prefetch" href="/assets/js/41.4c34e371.js"><link rel="prefetch" href="/assets/js/42.b90bda13.js"><link rel="prefetch" href="/assets/js/43.5cfe77a6.js"><link rel="prefetch" href="/assets/js/44.6bb4f33a.js"><link rel="prefetch" href="/assets/js/45.4ba03437.js"><link rel="prefetch" href="/assets/js/46.8f541616.js"><link rel="prefetch" href="/assets/js/47.61536cd3.js"><link rel="prefetch" href="/assets/js/48.478f71a0.js"><link rel="prefetch" href="/assets/js/49.f14d3fc6.js"><link rel="prefetch" href="/assets/js/5.0ba7bf9c.js"><link rel="prefetch" href="/assets/js/50.2c4375ea.js"><link rel="prefetch" href="/assets/js/51.99b9a6de.js"><link rel="prefetch" href="/assets/js/52.66d7a047.js"><link rel="prefetch" href="/assets/js/53.a3d76e1b.js"><link rel="prefetch" href="/assets/js/54.4912bc89.js"><link rel="prefetch" href="/assets/js/6.3be4ccd1.js"><link rel="prefetch" href="/assets/js/7.44679647.js"><link rel="prefetch" href="/assets/js/8.d8edd2eb.js"><link rel="prefetch" href="/assets/js/9.631d5f0b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.10edf211.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/logo-50.png" alt="LDH Note" class="logo"> <span class="site-name can-hide">LDH Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/Portfolio/" class="nav-link">
  Portfolio
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/Portfolio/" class="nav-link">
  Portfolio
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>CS</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/CS/Algorithm/" class="sidebar-link">Algorithm</a></li><li><a href="/CS/APS/" class="sidebar-link">APS</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>AI</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Blockchain</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default" data-v-45ca2890 data-v-45ca2890><h3 id="_2022-02-14-새로-알게된-점" data-v-45ca2890><a href="#_2022-02-14-새로-알게된-점" class="header-anchor" data-v-45ca2890>#</a> 2022/02/14, 새로 알게된 점</h3> <p class="tags" data-v-45ca2890>#machine_learning_project_flow #linux #shell_command #docker</p> <p data-v-45ca2890>  이번 주는 AI Product Serving 기초에 관하여 학습한다.<br data-v-45ca2890>
다루는 범위는 MLOps 개론부터 각종 개발 지식 전반을 보게되는데, 구체적인 키워드로는 다음과 같다.</p> <ul data-v-45ca2890><li data-v-45ca2890>Prototype ( Voila, Steamlit )</li> <li data-v-45ca2890>Linux</li> <li data-v-45ca2890>Cloud</li> <li data-v-45ca2890>CI/CD</li> <li data-v-45ca2890>Docker</li> <li data-v-45ca2890>Logging</li> <li data-v-45ca2890>MLflow</li> <li data-v-45ca2890>BentoML</li> <li data-v-45ca2890>Airflow</li> <li data-v-45ca2890>머신러닝 디자인 아키텍쳐</li></ul> <p data-v-45ca2890>많은 것들을 빠르게 배우지만, 언급한 것들 (ex. 라이브러리 등) 에 종속되지 말고, 왜 이러한 것들이 만들어졌는지 <strong data-v-45ca2890>이해</strong>할 수 있어야 한다 (추후에 다른 것을 사용할 수 있다).</p> <br data-v-45ca2890> <h4 id="머신러닝-프로젝트-flow" data-v-45ca2890><a href="#머신러닝-프로젝트-flow" class="header-anchor" data-v-45ca2890>#</a> 머신러닝 프로젝트 Flow</h4> <ul data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>문제 정의의 중요성</strong>    ➜   특정 현상을 파악하고 그 현상에 있는 <strong data-v-45ca2890>문제를 정의</strong>하는 과정
<ul data-v-45ca2890><li data-v-45ca2890>문제 정의( 본질을 파악하는 과정 )가 명확하지 않으면, 무엇을 해야할지 결정하기 어려워진다.</li></ul></li></ul> <p data-v-45ca2890>머신러닝 프로젝트의 흐름은 다음과 같다.</p> <br data-v-45ca2890> <ol data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>현상 파악</strong>   ➜   어떤 일이 발생 / 해당 일의 어려움 / 해결하면 좋은 것 / 추가적으로 해결해볼 요소 / 어떤 가설을 설정 / 데이터 성격 ...</li></ol> <br data-v-45ca2890> <ol start="2" data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>구체적인 문제 정의</strong>   ➜  정의한 구체적인 문제 상황을 일으키는 원인과 해결 방안 고민
<ul data-v-45ca2890><li data-v-45ca2890>문제를 쪼개서 파악하기, 해결 방식이 다양할 수 있음을 인지, 데이터로 해결할 수 있는 방법 고민, <strong data-v-45ca2890>점진적으로 실행</strong>하기</li></ul></li></ol> <br data-v-45ca2890> <ol start="3" data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>프로젝트 설계</strong> <ul data-v-45ca2890><li data-v-45ca2890>문제 정의 ➜ 최적화할 Metric 선택 ➜ 데이터 수집, 레이블 확인 ➜ 모델 개발 ➜ 예측 결과를 토대로 Error 분석 (잘못된 라벨이 왜 생기는지)</li> <li data-v-45ca2890>분석 후 다시 모델 학습 &amp; 더 많은 데이터 수집 ( 시간 흐름에 따라 성격이 달라짐 ) - 반복</li> <li data-v-45ca2890>학습할 패턴이 있다고 생각되는 문제에 머신러닝을 적용하면 좋다 (그것이 아니라면 굳이 머신러닝을 고집하지 않는 것이 좋을 수도 있다).
<ul data-v-45ca2890><li data-v-45ca2890>패턴이 있다면 <strong data-v-45ca2890>복잡한 것</strong>이 좋다.</li></ul></li> <li data-v-45ca2890>학습을 위한 <strong data-v-45ca2890>목적 함수</strong>를 만들 수 있어야 한다.</li></ul></li></ol> <br data-v-45ca2890> <ol start="4" data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>지표 결정</strong> <ul data-v-45ca2890><li data-v-45ca2890>Goal   ➜   프로젝트의 일반적인 목적. 큰 목적</li> <li data-v-45ca2890>Objectives   ➜   목적을 달성하기 위한 세부 단계의 목표 (구체적인 목적)
<ul data-v-45ca2890><li data-v-45ca2890>ex) NSFW (Not Safe For Work) 컨텐츠 필터링을 통해 사용자에게 불쾌감을 줄임</li></ul></li> <li data-v-45ca2890>목표를 설정하며 데이터를 확인 (있는 경우 / 애매한 경우 / 없는 경우)</li> <li data-v-45ca2890>Multiple Objective Optimizatoin
<ul data-v-45ca2890><li data-v-45ca2890>목적 함수가 여러개 있는 경우, 충돌할 수 있음</li> <li data-v-45ca2890>분리하는 것이 좋음
<ul data-v-45ca2890><li data-v-45ca2890>학습하기 쉬워야 함 (하나의 Objective 를 최적화하는 것이 여러 Objective 를 최적화하는 것보다 쉬움)</li> <li data-v-45ca2890>모델을 재학습하지 않도록 모델을 분리</li> <li data-v-45ca2890>Objective 별 유지 보수 일정이 다를 수 있음</li></ul></li></ul></li> <li data-v-45ca2890>제약조건 ( 일정 / 예산 / 개인정보 / 윤리 ... )</li> <li data-v-45ca2890>성능 ( Baseline / Threshold / Performance Trade-off / 해석 가능 여부 / Confidence Measurement )
<ul data-v-45ca2890><li data-v-45ca2890>유사한 문제를 해결하고 있는 <strong data-v-45ca2890>SOTA 논문 파악</strong>해보기</li></ul></li> <li data-v-45ca2890>프로토타입
<ul data-v-45ca2890><li data-v-45ca2890>Input 을 입력하면 Output 을 반환하는 웹페이지 ( 같은 조건에서는 디자인보다는 모델에 집중 )</li> <li data-v-45ca2890><span style="color:#2454ff;" data-v-45ca2890><strong data-v-45ca2890>Voila, Streamlit, Gradio</strong></span> 등을 활용</li></ul></li> <li data-v-45ca2890>Metric Evaluation
<ul data-v-45ca2890><li data-v-45ca2890>Objective 를 구해서 모델의 성능 지표는 확인했지만, 별개로 비즈니스 목표에 영향을 파악하는 것도 중요</li> <li data-v-45ca2890>ex) 작게는 RMSE 부터, 크게는 고객의 <strong data-v-45ca2890>재방문율</strong>, <strong data-v-45ca2890>매출</strong> 등</li> <li data-v-45ca2890>지표를 잘 정의해야 기존보다 더 성과를 냈는지 아닌지를 파악할 수 있음 ( <span style="color:#2454ff;" data-v-45ca2890><strong data-v-45ca2890>AB Test</strong></span>를 진행 )</li></ul></li></ul></li></ol> <br data-v-45ca2890> <ol start="5" data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>Action</strong> (모델 개발 후 배포 &amp; 모니터링)
<ul data-v-45ca2890><li data-v-45ca2890>어떤 결과를 내고 있는지</li> <li data-v-45ca2890>잘못 예측 시, 어떤 부분이 문제일지</li> <li data-v-45ca2890>어떤 부분을 기반으로 예측하고 있는지</li> <li data-v-45ca2890>Feature 의 어떤 값을 사용할 때 잘못 예측하는지</li></ul></li></ol> <br data-v-45ca2890> <ol start="6" data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>추가 원인 분석</strong></li></ol> <br data-v-45ca2890> <h4 id="비즈니스-모델" data-v-45ca2890><a href="#비즈니스-모델" class="header-anchor" data-v-45ca2890>#</a> 비즈니스 모델</h4> <p data-v-45ca2890>  비즈니스에 대한 이해도가 높을수록 문제 정의를 잘 할 가능성이 존재한다.</p> <ul data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>비즈니스 모델 파악하기</strong> <ul data-v-45ca2890><li data-v-45ca2890>해당 비즈니스 모델에서 어떤 데이터가 존재하고, 그 데이터를 기반으로 어떤 것을 만들 수 있을지 생각</li></ul> <ol data-v-45ca2890><li data-v-45ca2890>비즈니스 파악하기
<ul data-v-45ca2890><li data-v-45ca2890>비즈니스 모델을 파악하기 위해서 산업에 대해 정리해둔 Paper 가 있는지 찾아보자. ( ex. <strong data-v-45ca2890>Awesome Mobility Machine Learning GitHub</strong> )</li></ul></li> <li data-v-45ca2890>데이터를 활용할 수 있는 부분 (INPUT)
<ul data-v-45ca2890><li data-v-45ca2890>데이터 종류, 데이터로 할 수 있는 것, 데이터의 신뢰성 ...</li></ul></li> <li data-v-45ca2890>예측 결과가 활용되는 부분 (OUTPUT)
<ul data-v-45ca2890><li data-v-45ca2890>고객에게 바로 노출 (추천, 얼굴 필터 등) / 업무 자동화 ...</li></ul></li></ol></li></ul> <br data-v-45ca2890> <hr data-v-45ca2890> <h4 id="linux" data-v-45ca2890><a href="#linux" class="header-anchor" data-v-45ca2890>#</a> Linux</h4> <p data-v-45ca2890><strong data-v-45ca2890>Linux 를 알아야 하는 이유</strong></p> <p data-v-45ca2890>    ➜ 서버에서 자주 사용하는 OS (Mac, Window 도 가능하지만 유료 - 라이센스 구입해야 함)<br data-v-45ca2890>
    ➜ 오픈소스 (여러 버전이 존재하며, 커스텀 가능)<br data-v-45ca2890>
    ➜ 안정성, 신뢰성 (유닉스)<br data-v-45ca2890>
    ➜ 쉘 커맨드, 쉘 스크립트</p> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>대표적인 Linux 배포판</strong></p> <p data-v-45ca2890>  다양한 Linux 배포판이 있다 ➜ <a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg" target="_blank" rel="noopener noreferrer" data-v-45ca2890>참고<span data-v-45ca2890><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>Debian</strong>   ➜   온라인 커뮤니티에서 제작해 배포</li> <li data-v-45ca2890><strong data-v-45ca2890>Ubuntu</strong>   ➜   영국의 캐노니컬 회사에서 만든 배포판. 초보자들도 쉽게 접근할 수 있고, 설치도 쉽다.</li> <li data-v-45ca2890><strong data-v-45ca2890>Redhat</strong>   ➜   Red Hat 회사에서 배포한 리눅스</li> <li data-v-45ca2890><strong data-v-45ca2890>CentOS</strong>   ➜   Red Hat 이 공개한 버전을 가져와 브랜드와 로고를 제거하고 배포한 버전</li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>Linux 를 사용하는 방법</strong></p> <ul data-v-45ca2890><li data-v-45ca2890>VirtualBox 에 Linux 설치, Docker 로 설치</li> <li data-v-45ca2890>WSL 사용 (윈도우)</li> <li data-v-45ca2890>Notebook 에서 터미널 실행</li> <li data-v-45ca2890>Cloud 속 인스턴스 사용</li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>쉘의 종류</strong></p> <ul data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>쉘</strong>   ➜   사용자가 문자를 입력해 컴퓨터에 명령할 수 있도록 하는 프로그램</li> <li data-v-45ca2890><strong data-v-45ca2890>터미널/콘솔</strong>   ➜   쉘을 실행하기 위해 문자 입력을 받는 곳. 프로그램의 출력을 화면에 작성</li> <li data-v-45ca2890><strong data-v-45ca2890>sh</strong>   ➜   최초의 쉘</li> <li data-v-45ca2890><strong data-v-45ca2890>bash</strong>   ➜   Linux 표준 쉘</li> <li data-v-45ca2890><strong data-v-45ca2890>zsh</strong>   ➜   Mac 카탈리나 OS 기본 쉘</li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>쉘 UX</strong></p> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>username@hostname:current_folder</code> <ul data-v-45ca2890><li data-v-45ca2890>hostname   ➜   컴퓨터 네트워크에 접속된 장치에 할당된 이름으로, IP 대신 기억하기 쉬운 글자로 저장해 놓는다.</li></ul></li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>쉘을 사용하는 경우</strong></p> <ul data-v-45ca2890><li data-v-45ca2890>서버에서 접속해서 사용하는 경우</li> <li data-v-45ca2890><strong data-v-45ca2890>crontab</strong> 등 Linux 의 내장 기능을 활용하는 경우
<ul data-v-45ca2890><li data-v-45ca2890>crontab   ➜   서버 스스로 정해둔 명령을 <strong data-v-45ca2890>일정 기간마다 실행하도록 하는 것</strong></li></ul></li> <li data-v-45ca2890>데이터 전처리를 하기 위해 쉘 커맨드를 사용</li> <li data-v-45ca2890>Docker 를 사용하는 경우</li> <li data-v-45ca2890>수백대의 서버를 관리할 경우</li> <li data-v-45ca2890>Jupyter Notebook 의 Cell 에서 <code data-v-45ca2890>!</code> 를 붙치면 쉘 커맨드가 사용됨</li> <li data-v-45ca2890>터미널에서 python3, jupyter notebook 도 쉘 커맨드</li> <li data-v-45ca2890>Test Code 실행</li> <li data-v-45ca2890>배포 파이프라인 실행 (GitHub Action 등에서 실행)</li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>기본 쉘 커맨드</strong></p> <p data-v-45ca2890>mkdir, cd, ls, echo, wget, pwd, mv, cp, clear, history, cat, bash, export, alias ...</p> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>man</code> <ul data-v-45ca2890><li data-v-45ca2890>쉘 커맨드의 매뉴얼 문서를 보고 싶은 경우에 사용한다.</li> <li data-v-45ca2890><code data-v-45ca2890>man python</code></li> <li data-v-45ca2890>종료하려면 <code data-v-45ca2890>:q</code> 를 입력한다.</li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>mkdir</code>   ➜   폴더 생성하기 ( <strong data-v-45ca2890>M</strong>a<strong data-v-45ca2890>k</strong>e <strong data-v-45ca2890>Dir</strong>ectory ) - <code data-v-45ca2890>mkdir folder_name</code></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>ls</code> <ul data-v-45ca2890><li data-v-45ca2890>현재 접근한 폴더의 폴더/파일을 확인한다 ( <strong data-v-45ca2890>L</strong>ist <strong data-v-45ca2890>S</strong>egments ).</li> <li data-v-45ca2890>ls 뒤에 아무것도 작성하지 않으면 현재 폴더 기준으로 실행되고, 경로를 작성하면 해당 경로기준에서 실행한다.</li> <li data-v-45ca2890>옵션
<ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>-a</code>   ➜   <code data-v-45ca2890>.</code> 으로 시작하는 폴더/파일을 포함해 전체 파일을 출력한다.</li> <li data-v-45ca2890><code data-v-45ca2890>-l</code>   ➜   <strong data-v-45ca2890>퍼미션, 소유자, 만든 날짜, 용량</strong>까지 출력한다.</li> <li data-v-45ca2890><code data-v-45ca2890>-h</code>   ➜   용랑을 사람이 읽기 쉽도록 GB, MB 등으로 표현한다. ( <code data-v-45ca2890>-l</code> 과 같이 사용)</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>ls</code> <code data-v-45ca2890>ls ~</code> <code data-v-45ca2890>ls -al</code> <code data-v-45ca2890>ls -lh</code></li></ul></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>pwd</code>   ➜   현재 폴더 경로를 절대 경로로 보여준다 ( <strong data-v-45ca2890>P</strong>rint <strong data-v-45ca2890>W</strong>orking <strong data-v-45ca2890>D</strong>irectory ).</li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>cd</code>   ➜   폴더를 변경/이동한다. ( <strong data-v-45ca2890>C</strong>hange <strong data-v-45ca2890>D</strong>irectory ) - <code data-v-45ca2890>cd folder</code> <code data-v-45ca2890>cd folder_path</code></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>echo</code> <ul data-v-45ca2890><li data-v-45ca2890>터미널에 텍스트를 출력한다. - <code data-v-45ca2890>echo &quot;hi&quot;</code></li> <li data-v-45ca2890>echo <code data-v-45ca2890>쉘커맨드</code> 입력 시 쉘 커맨드의 결과를 출력한다.</li></ul></li></ul> <div class="language-bash extra-class" data-v-45ca2890><pre class="language-bash" data-v-45ca2890><code data-v-45ca2890><span class="token builtin class-name" data-v-45ca2890>echo</span> <span class="token variable" data-v-45ca2890><span class="token variable" data-v-45ca2890>`</span><span class="token builtin class-name" data-v-45ca2890>pwd</span><span class="token variable" data-v-45ca2890>`</span></span>
</code></pre></div><br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>vi</code> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>vi 파일명</code>   ➜   경로상에 파일이 없다면 vim 편집기로 파일을 생성하며 열리고, 아니면 기존 파일이 열린다.</li> <li data-v-45ca2890><strong data-v-45ca2890>Command Mode</strong>   ➜   vi 실행시 기본 모드이다.
<ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>dd</code>   ➜   현재 줄 삭제 (한 줄)</li> <li data-v-45ca2890><code data-v-45ca2890>i</code>   ➜   INSERT 모드로 변경</li> <li data-v-45ca2890><code data-v-45ca2890>x</code>   ➜   커서가 위치한 곳의 글자 1개 삭제 (누르는 만큼 반복)</li> <li data-v-45ca2890><code data-v-45ca2890>yy</code>   ➜   현재 줄을 복사</li> <li data-v-45ca2890><code data-v-45ca2890>p</code>   ➜   현재 커서가 있는 줄 바로 아래에 붙여넣기</li> <li data-v-45ca2890><code data-v-45ca2890>h</code>, <code data-v-45ca2890>j</code>, <code data-v-45ca2890>k</code>, <code data-v-45ca2890>l</code>   ➜   왼쪽 / 아래 / 위 / 오른쪽 으로 커서 움직이기</li></ul></li> <li data-v-45ca2890><strong data-v-45ca2890>Insert Mode</strong>   ➜   파일을 수정할 수 있는 모드로, Command Mode 로 다시 이동하려면 <code data-v-45ca2890>ESC</code> 를 누르면 된다.
<ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>w</code>   ➜   현재 파일명으로 저장한다.</li> <li data-v-45ca2890><code data-v-45ca2890>q</code>   ➜   vi 를 종료한다 (저장하지 않는다).</li> <li data-v-45ca2890><code data-v-45ca2890>q!</code>   ➜   vi 를 강제로 종료한다.</li> <li data-v-45ca2890><code data-v-45ca2890>wq</code>   ➜   저장 후 종료한다.</li> <li data-v-45ca2890><code data-v-45ca2890>/문자</code>   ➜   문자를 탐색한다. 탐색한 후 <code data-v-45ca2890>n</code> 을 누르면 반복해서 탐색을 실행한다.</li> <li data-v-45ca2890><code data-v-45ca2890>set nu</code>   ➜   vi 에서 라인별 번호를 표시한다.</li></ul></li> <li data-v-45ca2890><strong data-v-45ca2890>Last Line Mode</strong></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>bash</code>   ➜   쉘 스크립트를 실행한다. - <code data-v-45ca2890>bash filename.sh</code>   터미널에서 <strong data-v-45ca2890>Tab</strong> 을 누르면 자동완성된다.</li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>sudo</code> <ul data-v-45ca2890><li data-v-45ca2890>관리자 권한으로 실행하고 싶은 경우 커맨드 앞에 <code data-v-45ca2890>sudo</code> 를 붙인다.</li> <li data-v-45ca2890>sudo 명령어는 최고 권한을 가진 <strong data-v-45ca2890>슈퍼 유저</strong>로 프로그램을 실행한다.</li> <li data-v-45ca2890>모~~든 것을 다 삭제   ➜   <code data-v-45ca2890>sudo rm -rf /</code></li> <li data-v-45ca2890><code data-v-45ca2890>sudo</code> 사용은 자제하자. <code data-v-45ca2890>pip install</code> 시 안된다고 <code data-v-45ca2890>sudo pip install</code> 을 사용하면 개발 환경이 꼬일 수도 있다!
<ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>sudo pip install</code> 보단 <code data-v-45ca2890>pip install --user</code> 를 고려해보자.</li></ul></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>cp</code> <ul data-v-45ca2890><li data-v-45ca2890>폴더/파일을 복사한다. - <code data-v-45ca2890>cp copyed_name.sh pasted_name.sh</code></li> <li data-v-45ca2890><code data-v-45ca2890>-r</code>   ➜   디렉토리를 복사할 때, 디렉토리 안에 파일이 있으면 재귀적으로 모두 복사한다.</li> <li data-v-45ca2890><code data-v-45ca2890>-f</code>   ➜   복사할 때 이슈가 있어도 강제로 복사한다.</li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>mv</code>   ➜   폴더/파일을 이동하거나 이름을 바꿀 때 사용한다. - <code data-v-45ca2890>mv before_name.sh after_name.sh</code></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>cat</code> <ul data-v-45ca2890><li data-v-45ca2890>특정 파일 내용을 출력한다. - <code data-v-45ca2890>cat filename.sh</code></li> <li data-v-45ca2890>여러 파일을 인자로 주면 합쳐서 ( concat ) 출력한다. - <code data-v-45ca2890>cat file_1.sh file_2.sh</code></li> <li data-v-45ca2890>파일에 저장하고 ( overwrite ) 싶은 경우에는 다음과 같이 사용한다. - <code data-v-45ca2890>cat file_1.sh file_2.sh &gt; new_file.sh</code></li> <li data-v-45ca2890>파일에 추가하고 ( append ) 싶은 경우에는 다음과 같이 사용한다. - <code data-v-45ca2890>cat file_1.sh file_2.sh &gt;&gt; file_3.sh</code></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>clear</code>   ➜   터미널 창을 깨끗하게 해줌</li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>history</code> <ul data-v-45ca2890><li data-v-45ca2890>최근에 입력한 쉘 커맨드 history 를 출력한다.</li> <li data-v-45ca2890>History 결과에서 느낌표를 붙이고 해당 숫자 입력 시 그 커맨드를 다시 활용할 수 있다. - <code data-v-45ca2890>!20</code></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>find</code> <ul data-v-45ca2890><li data-v-45ca2890>파일/디렉토리를 검색할 때 사용한다.</li> <li data-v-45ca2890>현재 폴더에서 File 이름을 가지는 파일/디렉토리 검색   ➜   <code data-v-45ca2890>find . -name &quot;File&quot;</code></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>export</code> <ul data-v-45ca2890><li data-v-45ca2890>환경 변수를 설정하는데 사용된다. - <code data-v-45ca2890>export name='dooho'</code>   확인   ➜   <code data-v-45ca2890>echo $name</code></li> <li data-v-45ca2890>export 로 환경 변수를 설정한 경우, 터미널이 꺼지면 사라지게 된다.
<ul data-v-45ca2890><li data-v-45ca2890>매번 쉘을 실행할 때마다 환경변수를 저장하고 싶으면 <code data-v-45ca2890>.bashrc</code>, <code data-v-45ca2890>.zshrc</code> 에 저장하면 된다.</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>vi ~/.bashrc</code> 입력 후 나오는 편집기에서 <code data-v-45ca2890>export name='dooho'</code> 입력하고 <code data-v-45ca2890>:wq</code> 로 저장 후 종료</li> <li data-v-45ca2890>그 후 <code data-v-45ca2890>source ~/.bashrc</code> 로 즉시 적용시킨다 (하지 않으면, 재로그인해야 적용된다).</li></ul></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>alias</code> <ul data-v-45ca2890><li data-v-45ca2890>터미널에서 <code data-v-45ca2890>alias</code> 라고 치면 현재 별칭으로 설정된 것을 볼 수 있다.</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>alias ll2='ls -l'</code>   ➜   별칭을 등록한 것으로, <code data-v-45ca2890>ll2</code> 입력시 <code data-v-45ca2890>ls -l</code> 이 실행된다.</li></ul></li></ul> <br data-v-45ca2890> <h4 id="추가-쉘-커맨드" data-v-45ca2890><a href="#추가-쉘-커맨드" class="header-anchor" data-v-45ca2890>#</a> 추가 쉘 커맨드</h4> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>head</code>, <code data-v-45ca2890>tail</code>   ➜   파일의 앞/뒤 n 행을 출력한다. - <code data-v-45ca2890>head -n 4 filename.sh</code></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>sort</code> <ul data-v-45ca2890><li data-v-45ca2890>행 단위 정렬이다.</li> <li data-v-45ca2890><code data-v-45ca2890>-r</code>   ➜   내림차순 정렬 ( default=오름차순)</li> <li data-v-45ca2890><code data-v-45ca2890>-n</code>   ➜   Numeric Sort (사용하지 않으면 String Sort)</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>cat some_words_file.txt | sort</code> <code data-v-45ca2890>cat some_words_file.txt | sort -r</code></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>uniq</code> <ul data-v-45ca2890><li data-v-45ca2890>중복된 행이 <strong data-v-45ca2890>연속</strong>으로 있는 경우 중복 제거한다 ( sort 와 함께 자주 사용한다 ).</li> <li data-v-45ca2890><code data-v-45ca2890>-c</code>   ➜   중복 행의 개수 출력</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>cat words.txt | uniq</code> <code data-v-45ca2890>cat words.txt | sort | uniq</code> <code data-v-45ca2890>cat words.txt | uniq | wc -l</code> <code data-v-45ca2890>cat words.txt | sort | uniq | wc -l</code></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>grep</code> <ul data-v-45ca2890><li data-v-45ca2890>파일에 주어진 패턴 목록과 매칭되는 라인을 검색한다. - <code data-v-45ca2890>grep 옵션 패턴 파일_이름</code></li> <li data-v-45ca2890><code data-v-45ca2890>-i</code>   ➜   대소문자 구분 없이 찾기</li> <li data-v-45ca2890><code data-v-45ca2890>-w</code>   ➜   정확히 그 단어만 찾기</li> <li data-v-45ca2890><code data-v-45ca2890>-v</code>   ➜   특정 패턴 제외한 결과 출력</li> <li data-v-45ca2890><code data-v-45ca2890>-E</code>   ➜   정규 표현식 사용
<ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>^단어</code>   ➜   단어로 시작하는 것 찾기</li> <li data-v-45ca2890><code data-v-45ca2890>단어$</code>   ➜   단어로 끝나는 것 찾기</li> <li data-v-45ca2890><code data-v-45ca2890>.</code>   ➜   하나의 문자 매칭</li></ul></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>cut</code> <ul data-v-45ca2890><li data-v-45ca2890>파일에서 특정 필드를 추출한다.</li> <li data-v-45ca2890><code data-v-45ca2890>-f</code>   ➜   잘라낼 필드를 지정한다.</li> <li data-v-45ca2890><code data-v-45ca2890>-d</code>   ➜   필드를 구분하는 구분자를 지정한다. ( default=\t)</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>cat file.txt | cut -d : -f 1,7</code>   ➜   file.txt 내용 중에서 : 를 기준으로 나눴을 때, 1번째와 7번째를 가져옴</li></ul></li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>표준 스트림</strong></p> <p data-v-45ca2890>Unix 에서 동작하는 프로그램은 커맨드 실행시 <strong data-v-45ca2890>3개의 Stream 이 생성</strong>된다.</p> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>stdin</code>   ➜   0으로 펴현, 입력 (비밀번호, 커맨드 등)</li> <li data-v-45ca2890><code data-v-45ca2890>stdout</code>   ➜   1로 표현, 출력 값 (터미널에 나오는 값)</li> <li data-v-45ca2890><code data-v-45ca2890>stderr</code>   ➜   2로 표현, 디버깅 정보나 에러 출력</li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>Redirection &amp; Pipe</strong></p> <p data-v-45ca2890>Redirection 이란 프로그램의 출력( stdout )을 다른 파일이나 스트림으로 전달하는 것을 의미한다.</p> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>&gt;</code>   ➜   덮어쓰기 ( overwrite ) 파일이 없으면 생성하고 저장한다.</li> <li data-v-45ca2890><code data-v-45ca2890>&gt;&gt;</code>   ➜   맨 아래에 추가한다. ( append )</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>echo &quot;hi&quot; &gt; test_file.sh</code></li></ul> <p data-v-45ca2890>Pipe 는 프로그램의 출력( stdout )을 다른 프로그램의 입력으로 사용하고 싶은 경우에 사용한다.<br data-v-45ca2890>
A 의 Output 을 B 의 Input 으로 사용하는 등 다양한 커맨드 조합에 사용된다.</p> <p data-v-45ca2890>ex) 현재 폴더에 있는 파일명 중 vi 가 들어간 단어를 찾고 싶은 경우   ➜   <code data-v-45ca2890>ls | grep &quot;vi&quot;</code></p> <p data-v-45ca2890>ex) 찾은 결과를 저장하고 싶은 경우   ➜   <code data-v-45ca2890>ls | grep &quot;vi&quot; &gt; output.txt</code></p> <p data-v-45ca2890>ex) 최근 입력한 커맨드 중 echo 가 들어간 명령어 찾기   ➜   <code data-v-45ca2890>history | grep &quot;echo&quot;</code></p> <br data-v-45ca2890> <h4 id="서버에서-자주-사용하는-쉘-커맨드" data-v-45ca2890><a href="#서버에서-자주-사용하는-쉘-커맨드" class="header-anchor" data-v-45ca2890>#</a> 서버에서 자주 사용하는 쉘 커맨드</h4> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>ps</code> <ul data-v-45ca2890><li data-v-45ca2890>현재 실행되고 있는 프로세스를 출력한다. ( <strong data-v-45ca2890>P</strong>rocess <strong data-v-45ca2890>S</strong>tatus )</li> <li data-v-45ca2890><code data-v-45ca2890>-e</code>   ➜   모든 프로세스를 출력한다.</li> <li data-v-45ca2890><code data-v-45ca2890>-f</code>   ➜   Full Format 으로 자세히 보여준다.</li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>curl</code> <ul data-v-45ca2890><li data-v-45ca2890>Command Line 기반의 Data Transfer 커맨드이다. ( <strong data-v-45ca2890>C</strong>lient <strong data-v-45ca2890>URL</strong> )</li> <li data-v-45ca2890>웹 서버를 작성한 후 요청이 제대로 실행되는지 확인할 수 있다.</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>curl -X localhost:8080/ {data}</code></li> <li data-v-45ca2890>curl 외에 <strong data-v-45ca2890>httpie</strong> 등도 있다 (더 가독성있게 출력된다).</li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>df</code> <ul data-v-45ca2890><li data-v-45ca2890>현재 사용중인 디스크 용량 확인하는데 사용된다. ( <strong data-v-45ca2890>D</strong>isk <strong data-v-45ca2890>F</strong>ree )</li> <li data-v-45ca2890><code data-v-45ca2890>-h</code>   ➜   사람이 읽기 쉬운 형태로 출력한다.</li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>scp</code> <ul data-v-45ca2890><li data-v-45ca2890>SSH 를 이용해 네트워크로 연결된 호스트 간 <strong data-v-45ca2890>파일을 주고 받는 명령어</strong>이다. ( <strong data-v-45ca2890>S</strong>ecure <strong data-v-45ca2890>C</strong>o<strong data-v-45ca2890>p</strong>y )</li> <li data-v-45ca2890><code data-v-45ca2890>-r</code>   ➜   재귀적으로 복사한다.</li> <li data-v-45ca2890><code data-v-45ca2890>-P</code>   ➜   SSH 포트를 지정한다.</li> <li data-v-45ca2890><code data-v-45ca2890>-i</code>   ➜   SSH 설정을 활용해 실행한다. (key file 같이 입력해야 함)</li> <li data-v-45ca2890>ex) local ➜ remote - <code data-v-45ca2890>scp loacl_path user@ip:remote_directory</code></li> <li data-v-45ca2890>ex) remote ➜ local - <code data-v-45ca2890>scp user@ip:remote_directory local_path</code></li> <li data-v-45ca2890>ex) remote ➜ remote - <code data-v-45ca2890>scp user@ip:remote_directory user2@ip2:target_remote_directory</code></li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>nohup</code> <ul data-v-45ca2890><li data-v-45ca2890>터미널 종료 후에도 계속 작업이 유지하도록( <strong data-v-45ca2890>백그라운드 실행</strong> ) 하는 명령어이다.</li> <li data-v-45ca2890>ex) <code data-v-45ca2890>nohup python3 app.py &amp;</code></li> <li data-v-45ca2890>nohup 으로 실행될 파일은 <span style="color:#2454ff;" data-v-45ca2890><strong data-v-45ca2890>Permission 이 755</strong></span> 여야 한다.</li> <li data-v-45ca2890>종료는 <code data-v-45ca2890>ps ef | grep app.py</code> 한 후, <strong data-v-45ca2890>pid</strong>( Process ID ) 를 찾은 후 <code data-v-45ca2890>kill -9 pid</code> 방식으로 프로세스를 <strong data-v-45ca2890>kill</strong> 한다.</li> <li data-v-45ca2890><strong data-v-45ca2890>로그</strong>는 <strong data-v-45ca2890>nohub.out</strong> 에 저장된다.</li> <li data-v-45ca2890>nohup 외에도 <strong data-v-45ca2890>screen</strong> 이란 도구가 있다.</li></ul></li></ul> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>chmod</code> <ul data-v-45ca2890><li data-v-45ca2890>파일의 권한을 변경하는데 사용된다. ( <strong data-v-45ca2890>Ch</strong>ange <strong data-v-45ca2890>Mod</strong>e )</li> <li data-v-45ca2890>유닉스에서 파일이나 디렉토리의 시스템 모드를 변경한다.</li> <li data-v-45ca2890>권한 관련 사항은 <code data-v-45ca2890>ls -al</code> 을 입력하면 나온다.</li> <li data-v-45ca2890>Permission
<ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>r</code>   ➜   Read (읽기), <strong data-v-45ca2890>4</strong></li> <li data-v-45ca2890><code data-v-45ca2890>w</code>   ➜   Write (쓰기), <strong data-v-45ca2890>2</strong></li> <li data-v-45ca2890><code data-v-45ca2890>x</code>   ➜   eXecute (실행), <strong data-v-45ca2890>1</strong></li> <li data-v-45ca2890><code data-v-45ca2890>-</code>   ➜   Denied</li> <li data-v-45ca2890>세 가지 부분으로 나뉜다. <strong data-v-45ca2890>유저/그룹/그외</strong> <ul data-v-45ca2890><li data-v-45ca2890>ex) -rw-rw-r--   ➜   유저는 읽고 쓰기, 그룹은 읽고 쓰기, 그외는 읽기 권한만.</li></ul></li> <li data-v-45ca2890>ex) <code data-v-45ca2890>r-x</code>   ➜   읽거나 실행할 수는 있지만 수정은 불가능</li> <li data-v-45ca2890>ex) 755 or 644 로 퍼미션 주세요   ➜   rwx 를 더하면 4+2+1 = 7</li></ul></li> <li data-v-45ca2890>ex) <code data-v-45ca2890>chmod 755 filename.sh</code> 를 통해 filename.sh 의 권한이 755로 설정된다.</li></ul></li></ul> <br data-v-45ca2890> <h4 id="쉘-스크립트" data-v-45ca2890><a href="#쉘-스크립트" class="header-anchor" data-v-45ca2890>#</a> 쉘 스크립트</h4> <p data-v-45ca2890><code data-v-45ca2890>.sh</code> 파일을 생성하고, 그 안에 쉘 커맨드를 추가한 것을 말한다.
파이썬처럼 <code data-v-45ca2890>if</code>, <code data-v-45ca2890>while</code>, <code data-v-45ca2890>case</code> 문이 존재하며, 작성시 <code data-v-45ca2890>bash filename.sh</code> 로 실행 가능하다.</p> <p data-v-45ca2890>항상 상단에 Shebang 을 작성하여 어떤 쉘로 실행시킬 지 작성해야 한다.   ➜   <code data-v-45ca2890>#!bin/bash</code></p> <br data-v-45ca2890> <hr data-v-45ca2890> <h4 id="docker" data-v-45ca2890><a href="#docker" class="header-anchor" data-v-45ca2890>#</a> Docker</h4> <p data-v-45ca2890>Docker 를 배우기 전에 가상화 개념에 대해 알아야 한다.</p> <p data-v-45ca2890><strong data-v-45ca2890>가상화</strong></p> <p data-v-45ca2890>  개발할 때, 서비스 운용중인 서버에 직접 들어가서 개발하지 않는다.
주로 Local 환경에서 개발하고, 완료되면 Staging 서버에서 테스트 한 뒤, 통과하면 그때서야 Production 서버에 배포한다.</p> <p data-v-45ca2890>그런데 개발을 진행한 Local 환경과 Production <strong data-v-45ca2890>서버 환경</strong>이 다른 경우가 있다. (ex. Window vs. Linux)
예시처럼 OS 가 다르기 때문에 설치 시에도 다르게 진행해야 한다.
이외에도 Local 의 <strong data-v-45ca2890>환경 변수</strong>와 Production 서버의 환경 변수가 다르거나, <strong data-v-45ca2890>Permission</strong> 이 달라 작동하지 않는 경우가 있다.</p> <p data-v-45ca2890>그래서 이러한 문제를 해결하고자 README 에 설정들을 기록하고, 이대로 실행해달라고 한다.
하지만 매번 이런 작업을 하는 과정이 귀찮다. (운영하는 서버가 수백대라면..?)</p> <p data-v-45ca2890>서버 환경 설정까지도 모두 한 번에 소프트웨어화 할 수 없을까 해서 나온 개념이 <strong data-v-45ca2890>가상화</strong>이다 (엄밀하게는 하드웨어 가상화 등 더 넓은 개념이다).
특정 소프트웨어 환경을 만들고, Local, Production 서버에서 그대로 활용할 수 있도록 한다. 이를 통해,</p> <ul data-v-45ca2890><li data-v-45ca2890>개발과 운영 서버의 <strong data-v-45ca2890>환경 불일치가 해소</strong>되고,</li> <li data-v-45ca2890>어느 환경에서나 동일한 환경으로 프로그램을 실행할 수 있고,</li> <li data-v-45ca2890>개발 외에 Research 도 동일한 환경을 사용할 수 있다.</li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>Docker</strong> 가 등장하기 전에는, 가상화 기술로 주로 VM( Virtual Machine ) 을 사용하였다.
VM 은 호스트 머신이라고 하는 실제 물리적인 컴퓨터 위에, <strong data-v-45ca2890>OS 를 포함</strong>한 가상화 소프트웨어를 두는 방식으로 설계되었다.
GCP 의 Compute Engine 혹은 AWS EC2 가 이런 개념을 활용하였다 (미리 만든 이미지를 바탕으로 Computing 서비스를 통해 동일한 컴퓨팅 환경을 제공하였다).</p> <p data-v-45ca2890>하지만 이 방식은 OS 위에 OS 를 하나 더 실행시키기 때문에, 굉장히 <strong data-v-45ca2890>리소스를 잡아먹는다</strong>.
그래서 VM 의 무거움을 크게 덜어주면서, 가상화를 좀 더 경량화된 <strong data-v-45ca2890>프로세스의 개념</strong>으로 만든 <strong data-v-45ca2890>Container</strong> 기술이 나왔다.
이 Container 기술을 쉽게 사용할 수 있도록 나온 도구가 바로 <span style="color:#2454ff;" data-v-45ca2890><strong data-v-45ca2890>Docker</strong></span> 이다.</p> <p data-v-45ca2890>2013 년에 오픈소스로 등장하였고, <span style="color:#2454ff;" data-v-45ca2890><strong data-v-45ca2890>Container 에 기반한 개발과 운영을 매우 빠르게 확장할 수 있다는 장점</strong></span>이 있다.</p> <br data-v-45ca2890> <ul data-v-45ca2890><li data-v-45ca2890><p data-v-45ca2890><strong data-v-45ca2890>Docker Image</strong>   ➜   컨테이너를 실행할 때 사용할 수 있는 일종의 템플릿이다. (Read Only)</p></li> <li data-v-45ca2890><p data-v-45ca2890><strong data-v-45ca2890>Docker Container</strong>   ➜   Doceker Image 를 활용해 실행된 인스턴스로, Write 이 가능하다.</p></li></ul> <br data-v-45ca2890> <p data-v-45ca2890>다른 사람이 만든 Docker Image 를 가져와서, OS 구분없이 어디에서나 동일하게 실행할 수 있다.
물론 자신만의 Image 를 만들수도 있고, 공유할 수도 있다.
생성한 Image 를 원격 저장소에 저장하면 어디서나 사용할 수 있는데, 여기서 원격 저장소는 <strong data-v-45ca2890>Container Registry</strong> 로,
회사에서 서비스를 배포할 때는 원격 저장소에 이미지를 업로드하고, 서버에서 받아서 실행하는 식으로 진행한다.</p> <ul data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>dockerhub</strong>, <strong data-v-45ca2890>GCR</strong>, <strong data-v-45ca2890>ECR</strong>, ...</li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>Docker 사용법</strong></p> <p data-v-45ca2890>목표 - MySQL 실행하기</p> <ol data-v-45ca2890><li data-v-45ca2890><p data-v-45ca2890>이미지 가져오기 (mysql 8 버전의 이미지를 다운)   ➜   <code data-v-45ca2890>docker pull &quot;이미지_이름:태그&quot;</code></p> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>docker pull mysql:8</code></li></ul></li> <li data-v-45ca2890><p data-v-45ca2890>다운받은 이미지 확인   ➜   <code data-v-45ca2890>docker images</code></p></li> <li data-v-45ca2890><p data-v-45ca2890>다운받은 이미지 기반으로 컨테이서 실행   ➜   <code data-v-45ca2890>docker run &quot;이미지_이름:태그&quot;</code></p> <ul data-v-45ca2890><li data-v-45ca2890>`docker run --name mysql-tutorial -e MYSQL_ROOT_PASSWORD=1234 -d -p 3306:3306 mysql:8
<ul data-v-45ca2890><li data-v-45ca2890>mysql:8 버전을 3306 포트에서 데몬 방식(백그라운드)으로 mysql-tutorial 이란 이름으로 컨테이너를 생성하고 실행하는데, root 비밀번호는 1234 이다.</li></ul></li> <li data-v-45ca2890><code data-v-45ca2890>-e</code>   ➜   환경변수 설정</li> <li data-v-45ca2890><code data-v-45ca2890>-d</code>   ➜   데몬 모드(백그라운드). 이 설정을 하지 않으면, 현재 실행하는 쉘 위에서 컨테이너가 실행된다 (컨테이너를 나가면 실행이 종료된다).</li> <li data-v-45ca2890><code data-v-45ca2890>-p</code>   ➜   포트를 지정한다. (<strong data-v-45ca2890>로컬 호스트 포트:컨테이너 포트</strong>) 형태로, 해당 포트를 통해 통신한다.</li></ul></li> <li data-v-45ca2890><p data-v-45ca2890><strong data-v-45ca2890>실행중인</strong> 컨테이너 확인   ➜   <code data-v-45ca2890>docker ps</code></p> <ul data-v-45ca2890><li data-v-45ca2890>작동이 멈춘 컨테이너는 <code data-v-45ca2890>docker ps -a</code> 명령어로 확인할 수 있다.</li></ul></li> <li data-v-45ca2890><p data-v-45ca2890>백그라운드에서 실행 중인 컨테이너에 접속   ➜   <code data-v-45ca2890>docker exec -it &quot;컨테이너_이름(혹은 ID)&quot; /bin/bash</code></p> <ul data-v-45ca2890><li data-v-45ca2890>Compute Engine 에서 SSH 로 접속하는 것과 유사하다.</li></ul></li> <li data-v-45ca2890><p data-v-45ca2890>컨테이서 속 MYSQL 프로세스 들어가기   ➜   <code data-v-45ca2890>mysql -u root -p</code></p></li> <li data-v-45ca2890><p data-v-45ca2890>필요없는, <strong data-v-45ca2890>멈춘</strong> 컨테이너 삭제   ➜   <code data-v-45ca2890>docker rm &quot;컨테이너_이름(ID)&quot;</code></p> <ul data-v-45ca2890><li data-v-45ca2890>실행중인 컨테이너를 삭제하려면 <code data-v-45ca2890>docker rm &quot;컨테이너_이름(ID)&quot; -f</code> 로 <code data-v-45ca2890>-f</code> 옵션을 주면 되지만, 권장하지 않는다.</li></ul></li></ol> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>Tip</strong></p> <p data-v-45ca2890><code data-v-45ca2890>docker run</code> 할 때 파일을 공유하는 방법</p> <ul data-v-45ca2890><li data-v-45ca2890><strong data-v-45ca2890>Volume Mount</strong> <ul data-v-45ca2890><li data-v-45ca2890>Docker Container 내부는 특별한 설정이 없으면 <strong data-v-45ca2890>컨테이너를 삭제할 때 파일이 사라진다</strong>. 파일을 유지하려면 Host 와 Container 의 <strong data-v-45ca2890>저장소를 공유</strong>해야 한다.</li> <li data-v-45ca2890>Volumne Mount 를 진행하면 Host 와 Container 의 폴더가 공유된다.</li> <li data-v-45ca2890><code data-v-45ca2890>-v</code> 옵션을 사용하며, <code data-v-45ca2890>-p</code> 처럼 사용한다.   ➜   <code data-v-45ca2890>-v host_folder:container_folder</code></li> <li data-v-45ca2890>ex) <code data-v-45ca2890>docker run -it -p 8888:8888 -v /some/host/folder:/home/username/workspace</code></li></ul></li></ul> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>Docker Image 만들기</strong></p> <p data-v-45ca2890>직접 Docker Image 를 만들어보자. 목표는 FastAPI 를 실행하는 서버 이미지이다.</p> <ol data-v-45ca2890><li data-v-45ca2890><p data-v-45ca2890>먼저 폴더를 하나 만들고, 가상환경 세팅 후에 FastAPI 패키지를 설치한다.</p> <ol data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>mkdir fastAPI_Image &amp;&amp; cd fastAPI_Image</code></li> <li data-v-45ca2890><code data-v-45ca2890>python -m venv venv &amp;&amp; source venv/bin/activate</code></li> <li data-v-45ca2890><code data-v-45ca2890>pip install pip --upgrade</code></li> <li data-v-45ca2890><code data-v-45ca2890>pip install &quot;fastapi[all]&quot;</code></li></ol></li> <li data-v-45ca2890><p data-v-45ca2890>GET /hello 로 요청하면, 메시지를 전달하는 간단한 코드 작성</p></li></ol> <div class="language-python extra-class" data-v-45ca2890><pre class="language-python" data-v-45ca2890><code data-v-45ca2890><span class="token comment" data-v-45ca2890># main.py</span>
<span class="token keyword" data-v-45ca2890>from</span> fastapi <span class="token keyword" data-v-45ca2890>import</span> FastAPI
<span class="token keyword" data-v-45ca2890>import</span> uvicorn

app <span class="token operator" data-v-45ca2890>=</span> FastAPI<span class="token punctuation" data-v-45ca2890>(</span><span class="token punctuation" data-v-45ca2890>)</span>

<span class="token decorator annotation punctuation" data-v-45ca2890>@app<span class="token punctuation" data-v-45ca2890>.</span>get</span><span class="token punctuation" data-v-45ca2890>(</span><span class="token string" data-v-45ca2890>'/hello'</span><span class="token punctuation" data-v-45ca2890>)</span>
<span class="token keyword" data-v-45ca2890>def</span> <span class="token function" data-v-45ca2890>hello</span><span class="token punctuation" data-v-45ca2890>(</span><span class="token punctuation" data-v-45ca2890>)</span><span class="token punctuation" data-v-45ca2890>:</span>
    <span class="token keyword" data-v-45ca2890>return</span> <span class="token punctuation" data-v-45ca2890>{</span>
        <span class="token string" data-v-45ca2890>'message'</span><span class="token punctuation" data-v-45ca2890>:</span> <span class="token string" data-v-45ca2890>'world!'</span>
    <span class="token punctuation" data-v-45ca2890>}</span>


<span class="token keyword" data-v-45ca2890>if</span> __name__ <span class="token operator" data-v-45ca2890>==</span> '__main__<span class="token punctuation" data-v-45ca2890>:</span>
    uvicorn<span class="token punctuation" data-v-45ca2890>.</span>run<span class="token punctuation" data-v-45ca2890>(</span>app<span class="token punctuation" data-v-45ca2890>,</span> host<span class="token operator" data-v-45ca2890>=</span><span class="token string" data-v-45ca2890>'0.0.0.0'</span><span class="token punctuation" data-v-45ca2890>,</span> port<span class="token operator" data-v-45ca2890>=</span><span class="token number" data-v-45ca2890>8000</span><span class="token punctuation" data-v-45ca2890>)</span>
</code></pre></div><ol start="3" data-v-45ca2890><li data-v-45ca2890><p data-v-45ca2890>설치한 라이브러리를 따로 관리   ➜   <code data-v-45ca2890>pip freeze &gt; requirements.txt</code></p> <ul data-v-45ca2890><li data-v-45ca2890>의존성에 따라 설치된 라이브러리는 보이지 않게 하기   ➜   <code data-v-45ca2890>pip list --not-required --format=freeze &gt; requirements.txt</code></li></ul></li> <li data-v-45ca2890><p data-v-45ca2890><span style="color:#2454ff;" data-v-45ca2890><strong data-v-45ca2890>Dockerfile</strong></span> 라는 파일을 만들어 다음처럼 작성한다. (Docker Image 를 빌드하기 위한 정보가 담김)</p></li></ol> <div class="language-dockerfile extra-class" data-v-45ca2890><pre class="language-dockerfile" data-v-45ca2890><code data-v-45ca2890><span class="token instruction" data-v-45ca2890><span class="token keyword" data-v-45ca2890>FROM</span> python:3.8.7-slim-buster</span>

<span class="token instruction" data-v-45ca2890><span class="token keyword" data-v-45ca2890>COPY</span> . /app</span>
<span class="token instruction" data-v-45ca2890><span class="token keyword" data-v-45ca2890>WORKDIR</span> /app</span>
<span class="token instruction" data-v-45ca2890><span class="token keyword" data-v-45ca2890>ENV</span> PYTHONPATH=/app</span>
<span class="token instruction" data-v-45ca2890><span class="token keyword" data-v-45ca2890>ENV</span> PYTHONBUFFERED=1</span>

<span class="token instruction" data-v-45ca2890><span class="token keyword" data-v-45ca2890>RUN</span> pip install pip==21.2.4 &amp;&amp; <span class="token operator" data-v-45ca2890>\</span>
    pip install -r requirements.txt</span>

<span class="token instruction" data-v-45ca2890><span class="token keyword" data-v-45ca2890>CMD</span> [<span class="token string" data-v-45ca2890>&quot;python&quot;</span>, <span class="token string" data-v-45ca2890>&quot;main.py&quot;</span>]</span>
</code></pre></div><ul data-v-45ca2890><li data-v-45ca2890>Dockerhub 속 python:3.8.7-slim-buster 이미지를 바탕으로 작업 실행한 후 빌드</li> <li data-v-45ca2890><code data-v-45ca2890>COPY</code> 는 Dockerfile 이 존재하는 경로 기준 로컬 디렉토리를 컨테이너 내부의 디렉토리로 복사
<ul data-v-45ca2890><li data-v-45ca2890>파일을 컨테이너에서 사용하려면 COPY 명령어로 반드시 복사해야 함</li></ul></li> <li data-v-45ca2890><code data-v-45ca2890>WORKDIR</code> 는 RUN, CMD, ENTRYPOINT 등의 명령어를 실행할 컨테이너 경로를 지정하는 것을 말한다.
<ul data-v-45ca2890><li data-v-45ca2890>지정 후 명령어들은 컨테이너 내부의 <code data-v-45ca2890>/app</code> 에서 실행한다.</li></ul></li> <li data-v-45ca2890><code data-v-45ca2890>ENV</code> 는 컨테이너 내 환경변수를 지정하는 것으로써, <code data-v-45ca2890>ENV 환경변수_이름=값</code> 방식으로 사용한다.
<ul data-v-45ca2890><li data-v-45ca2890>파이썬 애플리케이션의 경우 통상 위 두 값을 지정한다.</li></ul></li> <li data-v-45ca2890><code data-v-45ca2890>CMD</code> 는 docker run 으로 이미지 기반 컨테이너를 만들 때, <strong data-v-45ca2890>실행할 명령어</strong>이다.
<ul data-v-45ca2890><li data-v-45ca2890>위의 이미지는 실행되는 즉시 <code data-v-45ca2890>python main.py</code> 를 실행하며, CMD 는 <strong data-v-45ca2890>띄어쓰기를 사용하지 않는다</strong>.</li></ul></li></ul> <ol start="5" data-v-45ca2890><li data-v-45ca2890><p data-v-45ca2890>Docker Image Build   ➜   <code data-v-45ca2890>docker build dockerfile_경로</code></p> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>-t 이미지_이름:태그</code> 옵션으로 이미지 이름과 태그를 지정할 수 있다.</li> <li data-v-45ca2890>태그 미지정시 <strong data-v-45ca2890>latest</strong> 로 채워짐</li></ul></li> <li data-v-45ca2890><p data-v-45ca2890>빌드가 완료되면, <code data-v-45ca2890>docker images</code> 명령어로 빌드한 이미지를 확인할 수 있다.</p></li> <li data-v-45ca2890><p data-v-45ca2890>빌드한 이미지 실행   ➜   <code data-v-45ca2890>docker run 이미지_이름:태그</code></p> <ul data-v-45ca2890><li data-v-45ca2890>ex) <code data-v-45ca2890>docker run -p 8000:8000 fastAPI-app</code></li> <li data-v-45ca2890>태그가 latest 라면 생략 가능하다.</li></ul></li> <li data-v-45ca2890><p data-v-45ca2890><code data-v-45ca2890>curl</code> 을 통해 애플리케이션이 작동하는지 테스트 할 수 있다.</p> <ul data-v-45ca2890><li data-v-45ca2890>ex) <code data-v-45ca2890>curl localhost:8000/hello</code></li></ul></li></ol> <br data-v-45ca2890> <p data-v-45ca2890><strong data-v-45ca2890>그 외에 Dockerfile 에서 사용하는 것</strong></p> <ul data-v-45ca2890><li data-v-45ca2890><code data-v-45ca2890>EXPOSE</code>   ➜   컨테이너 외부에 노출할 포트 지정</li> <li data-v-45ca2890><code data-v-45ca2890>ENTRYPOINT</code>   ➜   이미지를 컨테이너로 띄울 때 항상 실행하는 커맨드</li></ul> <br data-v-45ca2890> <br data-v-45ca2890></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div> <div></div> <br> <br> <footer class="siteFooter"><p>© 2021 이두호. ALL RIGHTS RESERVED.</p> <p><span>dhdev5ba@gmail.com</span> <span> </span> <a target="_blank" href="https://github.com/BlueYellowGreen/">GITHUB</a> <span> </span> <a target="_blank" href="https://www.linkedin.com/in/dooho-lee-56b295219/">LINKEDIN</a></p></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0ef05f26.js" defer></script><script src="/assets/js/2.7be8156e.js" defer></script><script src="/assets/js/29.b8b165d9.js" defer></script><script src="/assets/js/37.c7880ac5.js" defer></script>
  </body>
</html>
